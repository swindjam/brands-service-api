# Brands Service API

This is an API to return data on brands, and their associated products and stores.

# Overview

The data is stored in` src/brands.json` (with an extended version in `src/brands-generated.json`).

*Note*: the extended data includes all the original data, with generated data added for the embedded stores and products to make a larger dataset. The brands (`data` property is left unchanged to comply with the `per_page`property).

The following diagram shows the structure and relationships for this data.

// TODO insert diagram

### Assumptions

The following assumptions have been taken during the design of this API:
- The format of `brands.json` should be respected, with the assumption that the full dataset will be a larger version of this (e.g. something akin to `brands-generated.json`, which extends the `embedded` data as the size for this object is not specified).
- The `brands.json` file is used directly as the origin is not stated, and the data is therefore used "as is". From the fields it is structured like an API response, so it can be expected that we would interface with an API for this in the future, which it is assumed would be external to this application and have its own cache setup.
- The API structure should be resource based, with it easy to switch data providers in the future.
- The id specified in the URL should be validated.
- We should be specific about which properties we expose via the API.
- In integration tests, we are testing the logic and so only check that the correct resource has been returned and not all the individual properties.
- For 5xx errors, 500 is supported as the catch-all response generated by Fastly.

### Future extensibility:

- We can extend the fields we expose in the future, based on future requirements from applications accessing this API.
- We should fully understand the origin of `brands.json` and access it in a resilient manner. E.g. accessing it via it's external API which is behind a cache layer for resilience. If there is no external cache layer for the endpoint, we could setup an endpoint to act as a cache layer (only necessary if we do not control the API).
- The `dao` layer is setup so it could be easily changed to accessing the `brands.json` data from a SQL/NoSQL database in the future.
- There is no stated requirement for authentication and authorisation, but the API could be extended to add this. If we did add this, we would then need to consider the usage of a 404 or 403 for resources which cannot be found.
- A HTTPS setup is unnecessary, as this would be handled via a reverse proxy in a production version of the app, as per the Fastify recommendations (see https://fastify.dev/docs/latest/Guides/Recommendations/#use-a-reverse-proxy).
- A simplified cache mechanism is in place to demonstrate that this data should be cached, although in a production application it is recommended that this be behind a cache provider (such as Fastly or Varnish) for resilience and extra features (e.g. deployed in multiple locales).
- We should be more specific with 5xx errors, e.g. setting a timeout for the API routes with a 504 response to reduce the load on the system in production.

# Running the app

To run the app, run `docker-compose up` from the route directory. This will start a node instance that will run the API and rebuild on changes to the `src` code.

The node API has a memory restriction in place, to test scalability with a larger data set (i.e. that the app will nor suffer an OOM).

# Testing the app

There are unit and integration tests setup for the API.

To run the unit tests, run `npm test:unit`

To run the integration tests, run `npm run test:integration`
